<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

## 直接插入排序
### 排序思想
按照索引顺序，每一步将该索引上的值插入到前面已经有序的一组的值适当位置（通过从当前索引处往前的挨个比较找到的）上，直到全部插入为止。
### 算法步骤
1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个X元素，在已经排序的元素序列中从后向前扫描；
3. 如果扫描到的元素（已排序）大于X元素，将该元素往后移动一个位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于X元素的位置；
5. 将X元素插入到该位置；
6. 重复步骤2~4。

### 算法实现
1. 动图演示

    ![](http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA.gif)

2. [代码实现](../java/InsertSort.java?StraightInsertSort)
    ```java
    static class StraightInsertSort {
        static void sort(int[] e) {
            int j;
            for (int i = 1; i < e.length; i++) {
                int x = e[i];
                for (j = i - 1; j >= 0 && e[j] > x; j--) {
                    e[j + 1] = e[j];
                }
                e[j + 1] = x;
            }
        }
    }
    ```
   
### 结论
1. 当输入数据以**反序**输入时，直接插入排序的时间复杂度为\\(O(N^2)\\)，因为由于嵌套循环的每一个都花费N次迭代；
2. 当输入数据已**预先排序**，直接插入排序的时间复杂度为\\(O(N)\\)，因为内层的for循环的检测总是立即判定不成立而终止。
3. 插入排序适合**数据量比较小**的排序应用；
4. **逆序数**也正好是需要由插入排序执行的**交换次数**，而一个排过序的数组没有逆序。当输入数据是`34,8,64,51,32,21`时，该数据有9个逆序，即`(34,8),(34,32),(34,21),(64,51),(64,32),(64,21),(51,32),(51,21)`以及`(32,21)`。由于算法还有\\(O(N)\\)量的其他工作，因此插入排序的运行时间是\\(O(I+N)\\)，其中I为原始数组中的逆序数。于是，若逆序数是\\(O(N)\\)，则插入排序以线性时间运行。
5. N个互异数的数组的平均逆序数是\\(N(N-1)/4\\)；
6. 通过**交换相邻元素**进行排序的任何算法平均时间复杂度都需要\\(O(N^2)\\)，也就是说，为了使一个排序算法以\\(O(N^2)\\)时间运行，必须执行一些比较，特别是要对相距较远的元素进行交换。一个排序算法通过删除逆序得以向前进行，而为了有效的进行，他必须使每次交换删除不止一个逆序。

## 二分插入排序
### 排序思想
按照索引顺序，每一步将该索引上的值插入到前面已经有序的一组的值适当位置（通过二分查找法找到，可以减少比较次数）上，直到全部插入为止。

### 算法实现
1. [代码实现](../java/InsertSort.java?BinaryInsertSort)
    ```java
    public static class BinaryInsertSort {
    
        public static void sort(int[] array) {
            int left, current, mid, right;
            for (int i = 1; i < array.length; i++) {
                current = array[i];
                left = 0;
                right = i - 1;
                while (left <= right) {
                    mid = (left + right) / 2;
                    if (current > array[mid]) {
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }
                for (int k = i - 1; k >= left; k--) {
                    array[k + 1] = array[k];
                }
                if (left != i) {
                    array[left] = current;
                }
            }
        }
    }
    ```
    
### 结论
1. 当N比较大时，二分插入排序的比较次数比直接插入排序的最差情况要好得多，但是比直接插入排序的最好情况要差。
2. 当元素初始序列接近有序时，直接插入排序比二分插入排序的比较次数少。
3. 二分插入排序元素移动次数与直接插入排序相同，依赖于元素的初始序列。

## 希尔排序
### 排序思想
希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能，这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但到了这一步，数据几乎已经排好序。

如果有一个**很小的数据**在一个已按升序排好序的数组的**末端**，如果用复杂度为\\(O(N^2)\\)的排序算法（**冒泡排序**或**直接插入排序**），可能会进行**n次的比较和交换**才能将该数据移至正确的位置。而希尔排序会用**较大的步长**移动数据，所以小数据只需要进行**少数比较和交换**即可到正确位置。

### 算法步骤

### 算法实现
1. 算法图解

    ![](http://op87q3xru.bkt.clouddn.com/java/images/algorithm%E8%B0%A2%E5%B0%94%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3.png)
    
2. 代码实现
    ```java
    public static class ShellSort {
   
        public static void sort(int[] e) {
            for (int gap = e.length / 2; gap > 0; gap /= 2) {
                int j;
                for (int i = gap; i < e.length; i++) {
                    int current = e[i];
                    for (j = i - gap; j >= 0 && e[j] > current; j -= gap) {
                        e[j + gap] = e[j];
                    }
                    e[j + gap] = current;
                }
            }
        }
    }
    ```
### 结论
1. \\(h_k\\)排序的实质就是，将\\(h_k\\)，\\(h_k+1\\)，···，\\(N-1\\)中的每个位置i，把该位置对应的元素放到\\(i-{h_k}\\)中的正确位置上。
2. 一趟\\(h_k\\)排序的作用就是对\\(h_k\\)个独立的子数组执行一次插入排序。
3. 使用增量序列\\(h_k\\)进行一趟排序后，对于每个i我们都有\\(a[i]<=a[i+h_k]\\)，所有相隔\\(h_k\\)的元素都被排序，此时称文件时\\(h_k\\)排序的。
4. 一个\\(h_k\\)排序的文件（然后是\\(h_{k-1}\\)排序）会一直保持它的\\(h_k\\)排序性，前面各趟排序的成果不会被后面的排序打乱。
5. 希尔排序**不是稳定的排序算法**
    
    虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性将会被打乱。
    
    比如序列{ 3, 5, 10, **8**, 7, 2, _8_, 1, 20, 6 }h=2时分成两个子序列 { 3, 10, 7, _8_, 20 } 和  { 5, **8**, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, _8_, 10, 20 } 和 { 1, 2, 5, 6, **8** } ，即 { 3, 1, 7, 2, _8_, 5, 10, 6, 20, **8** } ，两个8的相对次序发生了改变。


## 插入排序综合比较
| 名称 | 最差时间复杂度 | 最优时间复杂度 | 平均时间复杂度 | 辅助空间 | 稳定性 |
|:---:|:-------------:|:------------:|:------------:|:------:|:-----:|
| 直接插入排序 | \\(O(N^2)\\) | \\(O(N)\\) | \\(O(N^2)\\) | \\(O(1)\\) | 稳定 |
| 二分插入排序 | \\(O(N^2)\\) | \\(O(NlogN)\\) | \\(O(N^2)\\) | \\(O(1)\\) | 稳定 |
| 希尔排序 | 根据步长序列的不同而不同，最坏是\\(O(N^2)\\) | \\(O(N)\\) | 根据步长的不同而不同 | \\(O(1)\\) | 不稳定 |


## 参考资料
1. [常用排序算法总结(一)](http://www.cnblogs.com/eniac12/p/5329396.html)
2. [八大排序，各显神通](http://blog.csdn.net/u010850027/article/details/49362279)